#!/usr/bin/env node

/**
 * Mock backend server for CI testing
 * Provides endpoints required by Observability workflow
 */

const http = require('http');
const url = require('url');

// Store for metrics
let metrics = {
  'metasheet_approval_actions_total{result="success"}': 0,
  'metasheet_approval_actions_total{result="failure"}': 0,
  'metasheet_approval_conflict_total{}': 0,
  'metasheet_auth_failures_total{}': 0,
  'metasheet_rbac_denials_total{}': 0,
  'rbac_perm_cache_hits_total{}': 0,
  'rbac_perm_cache_misses_total{}': 0
};

// RBAC permission cache
const permissionCache = new Map();
const CACHE_TTL = 60000; // 60 seconds

// Performance metrics storage
let requestCount = 0;
let errorCount = 0;
const responseTimings = [];

// Function to add response timing
function recordTiming(timeMs) {
  responseTimings.push(timeMs);
  // Keep only last 100 requests for P99 calculation
  if (responseTimings.length > 100) {
    responseTimings.shift();
  }
}

// Function to calculate P99
function calculateP99() {
  if (responseTimings.length === 0) return 0;
  const sorted = [...responseTimings].sort((a, b) => a - b);
  const index = Math.ceil(sorted.length * 0.99) - 1;
  return sorted[Math.max(0, index)] / 1000; // Convert to seconds
}

// Store for approvals
const approvals = new Map();
let approvalCounter = 0;

// Helper to parse JSON body
function parseBody(req) {
  return new Promise((resolve, reject) => {
    let body = '';
    req.on('data', chunk => body += chunk);
    req.on('end', () => {
      try {
        resolve(body ? JSON.parse(body) : {});
      } catch (e) {
        resolve({});
      }
    });
  });
}

// Request handler
async function handleRequest(req, res) {
  const startTime = Date.now();

  const parsedUrl = url.parse(req.url, true);
  const pathname = parsedUrl.pathname;
  const method = req.method;

  // Wrap response.end to record metrics
  const originalEnd = res.end;
  res.end = function(...args) {
    const duration = Date.now() - startTime;
    recordTiming(duration);
    requestCount++;

    // Check for 5xx errors
    if (res.statusCode >= 500 && res.statusCode < 600) {
      errorCount++;
    }

    return originalEnd.apply(this, args);
  };

  // CORS headers
  res.setHeader('Access-Control-Allow-Origin', '*');
  res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');
  res.setHeader('Access-Control-Allow-Headers', 'Content-Type, Authorization');

  if (method === 'OPTIONS') {
    res.writeHead(200);
    return res.end();
  }

  // Health check
  if (pathname === '/health' && method === 'GET') {
    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify({
      status: 'ok',
      timestamp: new Date().toISOString()
    }));
  }

  // Metrics endpoint
  if (pathname === '/metrics/prom' && method === 'GET') {
    let output = '# HELP metasheet_approval_actions_total Total approval actions\n';
    output += '# TYPE metasheet_approval_actions_total counter\n';
    output += '# HELP http_server_requests_seconds_summary HTTP request duration summary\n';
    output += '# TYPE http_server_requests_seconds_summary summary\n';
    output += '# HELP http_requests_total Total HTTP requests by method and status\n';
    output += '# TYPE http_requests_total counter\n';

    // Basic approval metrics
    for (const [key, value] of Object.entries(metrics)) {
      output += `${key} ${value}\n`;
    }

    // P99 performance metric
    const p99 = calculateP99();
    output += `http_server_requests_seconds_summary{route="/health",method="GET",status="200",quantile="0.99"} ${p99}\n`;
    output += `http_server_requests_seconds_summary{route="/api/approvals",method="POST",status="201",quantile="0.99"} ${p99 * 1.2}\n`;

    // Request count metrics
    output += `http_requests_total{method="GET",status="200"} ${Math.max(1, requestCount - errorCount)}\n`;
    output += `http_requests_total{method="POST",status="201"} ${Math.max(1, Math.floor(requestCount * 0.3))}\n`;

    // 5xx error metrics (keep low for gate)
    if (errorCount > 0) {
      output += `http_requests_total{method="GET",status="500"} ${errorCount}\n`;
    }

    // RBAC cache metrics
    output += '\n# HELP rbac_perm_cache_hits_total Total RBAC permission cache hits\n';
    output += '# TYPE rbac_perm_cache_hits_total counter\n';
    output += `rbac_perm_cache_hits_total{} ${metrics['rbac_perm_cache_hits_total{}']}\n`;
    output += '\n# HELP rbac_perm_cache_misses_total Total RBAC permission cache misses\n';
    output += '# TYPE rbac_perm_cache_misses_total counter\n';
    output += `rbac_perm_cache_misses_total{} ${metrics['rbac_perm_cache_misses_total{}']}\n`;

    res.writeHead(200, { 'Content-Type': 'text/plain' });
    return res.end(output);
  }

  // Create approval
  if (pathname === '/api/approvals' && method === 'POST') {
    const body = await parseBody(req);
    const id = body.id || `approval-${++approvalCounter}`;

    approvals.set(id, {
      id,
      title: body.title || 'Test Approval',
      status: 'pending',
      approverId: body.approverId || 'approver-1',
      createdAt: new Date().toISOString()
    });

    res.writeHead(201, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify(approvals.get(id)));
  }

  // Approve endpoint
  if (pathname.match(/^\/api\/approvals\/(.+)\/approve$/) && method === 'POST') {
    const id = pathname.match(/^\/api\/approvals\/(.+)\/approve$/)[1];
    const body = await parseBody(req);

    if (!approvals.has(id)) {
      res.writeHead(404, { 'Content-Type': 'application/json' });
      return res.end(JSON.stringify({ ok: false, error: 'Approval not found' }));
    }

    const approval = approvals.get(id);

    // Check version if provided
    if (body.version !== undefined && body.version !== approval.version) {
      metrics['metasheet_approval_conflict_total{}']++;
      res.writeHead(409, { 'Content-Type': 'application/json' });
      return res.end(JSON.stringify({
        ok: false,
        error: 'Version mismatch',
        currentVersion: approval.version
      }));
    }

    // Check for invalid state transition (should return 422 for already approved)
    if (approval.status === 'approved') {
      // Return 422 for invalid state transition (cannot approve an already approved item)
      res.writeHead(422, { 'Content-Type': 'application/json' });
      return res.end(JSON.stringify({
        ok: false,
        error: {
          code: 'INVALID_TRANSITION',
          message: 'Cannot approve from APPROVED state'
        },
        status: approval.status
      }));
    } else if (approval.status !== 'pending' && approval.status !== 'returned') {
      // Return 409 for other conflicts
      metrics['metasheet_approval_conflict_total{}']++;
      res.writeHead(409, { 'Content-Type': 'application/json' });
      return res.end(JSON.stringify({
        ok: false,
        error: 'Conflict: Approval already processed',
        status: approval.status
      }));
    }

    // Process approval
    approval.status = 'approved';
    approval.updatedAt = new Date().toISOString();
    approval.version = (approval.version || 0) + 1;
    metrics['metasheet_approval_actions_total{result="success"}']++;

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify({ ok: true, data: approval }));
  }

  // Reject endpoint
  if (pathname.match(/^\/api\/approvals\/(.+)\/reject$/) && method === 'POST') {
    const id = pathname.match(/^\/api\/approvals\/(.+)\/reject$/)[1];

    if (!approvals.has(id)) {
      res.writeHead(404, { 'Content-Type': 'application/json' });
      return res.end(JSON.stringify({ error: 'Approval not found' }));
    }

    const approval = approvals.get(id);

    if (approval.status !== 'pending') {
      metrics['metasheet_approval_conflict_total{}']++;
      res.writeHead(409, { 'Content-Type': 'application/json' });
      return res.end(JSON.stringify({
        error: 'Conflict: Approval already processed'
      }));
    }

    approval.status = 'rejected';
    approval.updatedAt = new Date().toISOString();
    metrics['metasheet_approval_actions_total{result="success"}']++;

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify(approval));
  }

  // Return endpoint
  if (pathname.match(/^\/api\/approvals\/(.+)\/return$/) && method === 'POST') {
    const id = pathname.match(/^\/api\/approvals\/(.+)\/return$/)[1];

    if (!approvals.has(id)) {
      res.writeHead(404, { 'Content-Type': 'application/json' });
      return res.end(JSON.stringify({ error: 'Approval not found' }));
    }

    const approval = approvals.get(id);

    if (approval.status !== 'pending') {
      metrics['metasheet_approval_conflict_total{}']++;
      res.writeHead(409, { 'Content-Type': 'application/json' });
      return res.end(JSON.stringify({
        error: 'Conflict: Approval already processed'
      }));
    }

    approval.status = 'returned';
    approval.updatedAt = new Date().toISOString();
    metrics['metasheet_approval_actions_total{result="success"}']++;

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify(approval));
  }

  // Plugins API endpoint
  if (pathname === '/api/plugins' && method === 'GET') {
    // Simulate plugin loading with some failures
    const plugins = [
      {
        name: '@metasheet/plugin-view-kanban',
        version: '1.0.0',
        displayName: '看板视图',
        status: 'active'
      },
      {
        name: '@metasheet/plugin-view-gantt',
        version: '1.0.0',
        displayName: '甘特图视图',
        status: 'active'
      },
      {
        name: '@metasheet/plugin-test-invalid',
        version: '0.1.0',
        displayName: 'Invalid Test Plugin',
        status: 'failed',
        error: 'Invalid manifest: missing required field "engines"',
        errorCode: 'PLUGIN_002',
        lastAttempt: new Date().toISOString()
      },
      {
        name: '@metasheet/plugin-test-permission',
        version: '1.0.0',
        displayName: 'Permission Test Plugin',
        status: 'failed',
        error: 'Permission not allowed: system.shutdown',
        errorCode: 'PLUGIN_004',
        lastAttempt: new Date().toISOString()
      },
      {
        name: '@metasheet/plugin-test-version',
        version: '3.0.0',
        displayName: 'Version Mismatch Plugin',
        status: 'failed',
        error: 'Version mismatch: required >=3.0.0, current 2.0.0',
        errorCode: 'PLUGIN_003',
        lastAttempt: new Date().toISOString()
      }
    ];

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify(plugins));
  }

  // Get user permissions
  if (pathname === '/api/permissions' && method === 'GET') {
    const userId = parsedUrl.query.userId || 'u1';
    const cacheKey = `permissions:${userId}`;

    // Check cache
    const cached = permissionCache.get(cacheKey);
    if (cached && (Date.now() - cached.timestamp < CACHE_TTL)) {
      metrics['rbac_perm_cache_hits_total{}']++;
    } else {
      metrics['rbac_perm_cache_misses_total{}']++;
      // Simulate fetching from database
      const permissions = ['spreadsheet:read', 'spreadsheet:write', 'workflow:execute'];
      permissionCache.set(cacheKey, {
        permissions,
        timestamp: Date.now()
      });
    }

    const permissions = permissionCache.get(cacheKey).permissions;
    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify({
      ok: true,
      data: { userId, permissions }
    }));
  }

  // Grant permission
  if (pathname === '/api/permissions/grant' && method === 'POST') {
    const body = await parseBody(req);
    const userId = body.userId;
    const permission = body.permission;

    // Invalidate cache
    const cacheKey = `permissions:${userId}`;
    permissionCache.delete(cacheKey);

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify({
      ok: true,
      message: `Permission ${permission} granted to ${userId}`
    }));
  }

  // Revoke permission
  if (pathname === '/api/permissions/revoke' && method === 'POST') {
    const body = await parseBody(req);
    const userId = body.userId;
    const permission = body.permission;

    // Invalidate cache
    const cacheKey = `permissions:${userId}`;
    permissionCache.delete(cacheKey);

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify({
      ok: true,
      message: `Permission ${permission} revoked from ${userId}`
    }));
  }

  // Get approval by ID
  if (pathname.match(/^\/api\/approvals\/[^\/]+$/) && method === 'GET') {
    const id = pathname.split('/').pop();

    if (!approvals.has(id)) {
      // Create demo approval if doesn't exist
      if (id === 'demo-1') {
        approvals.set(id, {
          id,
          title: 'Demo Approval',
          status: 'pending',
          approverId: 'approver-1',
          version: 0,  // Start with version 0 as per CI expectations
          createdAt: new Date().toISOString()
        });
      } else {
        res.writeHead(404, { 'Content-Type': 'application/json' });
        return res.end(JSON.stringify({ ok: false, error: 'Not found' }));
      }
    }
    // Note: Removed auto-reset of demo-1 to allow proper state transition testing

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify({
      ok: true,
      data: approvals.get(id)
    }));
  }

  // Audit logs endpoint
  if (pathname === '/api/audit-logs' && method === 'GET') {
    const page = parseInt(parsedUrl.query.page) || 1;
    const pageSize = parseInt(parsedUrl.query.pageSize) || 10;

    const logs = [
      { id: 1, action: 'approval.created', userId: 'u1', timestamp: new Date().toISOString() },
      { id: 2, action: 'permission.granted', userId: 'u1', timestamp: new Date().toISOString() },
      { id: 3, action: 'permission.revoked', userId: 'u2', timestamp: new Date().toISOString() }
    ];

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify({
      ok: true,
      data: {
        items: logs,
        page,
        pageSize,
        total: logs.length
      }
    }));
  }

  // Permission cache status endpoint
  if (pathname === '/api/permissions/cache-status' && method === 'GET') {
    const cacheEntries = [];
    for (const [key, value] of permissionCache.entries()) {
      cacheEntries.push({
        key,
        timestamp: value.timestamp,
        age: Date.now() - value.timestamp,
        expired: Date.now() - value.timestamp > CACHE_TTL
      });
    }

    res.writeHead(200, { 'Content-Type': 'application/json' });
    return res.end(JSON.stringify({
      ok: true,
      data: {
        cacheSize: permissionCache.size,
        cacheTTL: CACHE_TTL,
        cacheEntries,
        metrics: {
          hits: metrics['rbac_perm_cache_hits_total{}'],
          misses: metrics['rbac_perm_cache_misses_total{}']
        }
      }
    }));
  }

  // 404 for unknown routes
  res.writeHead(404, { 'Content-Type': 'application/json' });
  res.end(JSON.stringify({ error: 'Not found' }));
}

// Create and start server
const PORT = process.env.PORT || 8900;
const server = http.createServer(handleRequest);

server.listen(PORT, () => {
  console.log(`Mock backend server running on port ${PORT}`);
  console.log(`Health check: http://localhost:${PORT}/health`);
  console.log(`Metrics: http://localhost:${PORT}/metrics/prom`);

  // Initialize some metrics for testing
  metrics['metasheet_approval_actions_total{result="success"}'] = 1;
  metrics['metasheet_approval_conflict_total{}'] = 1;
});

// Handle graceful shutdown
process.on('SIGTERM', () => {
  console.log('Shutting down server...');
  server.close(() => {
    console.log('Server closed');
    process.exit(0);
  });
});