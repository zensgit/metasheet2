import { db } from '../db/db'
import { toDateValue } from '../db/type-helpers'
import { SnapshotService } from './SnapshotService'
import { auditLog } from '../audit/audit'
import { notificationService } from './NotificationService'

export interface ChangeRequestInput {
  snapshotId: string
  title: string
  description?: string
  changeType: string
  targetEnvironment: string
  requestedBy: string
  requiredApprovals?: number
}

export interface ChangeRequest {
  id: string
  snapshot_id: string
  title: string
  description: string | null
  change_type: string
  target_environment: string
  requested_by: string
  required_approvals: number
  auto_generated_notes: string | null  // Database allows null
  risk_score: number
  impact_assessment: string
  status: string
  current_approvals: number
  approvers: string[]
  metadata: string
  created_at?: Date
  updated_at?: Date
  deployed_at?: Date | null
  deployed_by?: string | null
  rolled_back_at?: Date | null
  rolled_back_by?: string | null
  rollback_reason?: string | null
}

export interface ChangeRequestResult {
  changeRequest: ChangeRequest
  riskScore: number
  impactAssessment: ImpactAssessment
  autoGeneratedNotes: string
  warnings: string[]
}

export interface ImpactAssessment {
  affectedItems: number
  affectedViews: string[]
  hasSchemaChanges: boolean
  hasDataChanges: boolean
  estimatedDowntime: number // seconds
  riskFactors: string[]
}

export class ChangeManagementService {
  private snapshotService: SnapshotService

  constructor() {
    this.snapshotService = new SnapshotService()
  }

  /**
   * Create a change request
   */
  async createChangeRequest(input: ChangeRequestInput): Promise<ChangeRequestResult> {
    // 1. Get snapshot info
    const snapshot = await this.snapshotService.getSnapshot(input.snapshotId)
    if (!snapshot) throw new Error('Snapshot not found')

    // 2. Assess risk
    const riskScore = await this.assessRisk(snapshot, input.targetEnvironment)

    // 3. Analyze impact
    const impactAssessment = await this.analyzeImpact(snapshot)

    // 4. Generate change notes
    const autoGeneratedNotes = await this.generateChangeNotes(snapshot)

    // 5. Determine required approvals
    let requiredApprovals = input.requiredApprovals || 1
    if (input.targetEnvironment === 'production') {
      requiredApprovals = Math.max(requiredApprovals, 2)
    }
    if (riskScore > 0.7) {
      requiredApprovals = Math.max(requiredApprovals, 3)
    }

    // 6. Create change request
    const changeRequest = await db
      .insertInto('change_requests')
      .values({
        snapshot_id: input.snapshotId,
        title: input.title,
        description: input.description || null,
        change_type: input.changeType,
        target_environment: input.targetEnvironment,
        requested_by: input.requestedBy,
        required_approvals: requiredApprovals,
        auto_generated_notes: autoGeneratedNotes,
        risk_score: riskScore,
        impact_assessment: JSON.stringify(impactAssessment),
        status: 'pending',
        current_approvals: 0,
        approvers: [],
        metadata: JSON.stringify({})
      })
      .returningAll()
      .executeTakeFirstOrThrow()

    // 7. Audit log
    await auditLog({
      actorId: input.requestedBy,
      actorType: 'user',
      action: 'create_change_request',
      resourceType: 'change_request',
      resourceId: changeRequest.id,
      meta: { changeRequest }
    })

    // 8. Notify reviewers
    if (requiredApprovals > 0) {
      // In a real system, we would look up reviewers based on rules/roles
      // For now, we'll just log/mock it or send to a default channel if configured
      try {
        await notificationService.send({
          channel: 'email',
          subject: `New Change Request: ${input.title}`,
          content: `A new change request requires approval.\n\nTitle: ${input.title}\nRequested By: ${input.requestedBy}\nEnvironment: ${input.targetEnvironment}\nRisk Score: ${riskScore}`,
          recipients: [{ type: 'user', id: 'admin' }] // Mock recipient
        })
      } catch (e) {
        // Ignore notification failures
      }
    }

    // 9. Generate warnings
    const warnings = this.generateWarnings(riskScore, impactAssessment, input.targetEnvironment)

    // Metrics (assuming metrics object has this counter, if not we should add it or ignore for now)
    // metrics.changeRequestsCreatedTotal.labels(input.changeType, input.targetEnvironment).inc()

    // Convert database result to ChangeRequest type
    // impact_assessment and metadata are returned as Record from DB but stored as JSON strings
    const changeRequestResult: ChangeRequest = {
      ...changeRequest,
      impact_assessment: typeof changeRequest.impact_assessment === 'string'
        ? changeRequest.impact_assessment
        : JSON.stringify(changeRequest.impact_assessment),
      metadata: typeof changeRequest.metadata === 'string'
        ? changeRequest.metadata
        : JSON.stringify(changeRequest.metadata)
    }

    return {
      changeRequest: changeRequestResult,
      riskScore,
      impactAssessment,
      autoGeneratedNotes,
      warnings
    }
  }

  /**
   * Approve a change request
   */
  async approveChangeRequest(
    changeRequestId: string,
    approverId: string,
    comment?: string
  ): Promise<{ approved: boolean; readyToDeploy: boolean }> {
    const cr = await db
      .selectFrom('change_requests')
      .where('id', '=', changeRequestId)
      .selectAll()
      .executeTakeFirst()

    if (!cr) throw new Error('Change request not found')

    if (cr.status !== 'pending') {
      throw new Error(`Cannot approve: status is ${cr.status}`)
    }

    // Check if already approved
    const existingApproval = await db
      .selectFrom('change_approvals')
      .where('change_request_id', '=', changeRequestId)
      .where('approver_id', '=', approverId)
      .executeTakeFirst()

    if (existingApproval) {
      throw new Error('Already approved by this user')
    }

    // Record approval
    await db.insertInto('change_approvals').values({
      change_request_id: changeRequestId,
      approver_id: approverId,
      decision: 'approved',
      comment: comment || null
    }).execute()

    // Update approval count
    const newApprovalCount = (cr.current_approvals || 0) + 1
    const approvers = cr.approvers ? [...cr.approvers, approverId] : [approverId]
    
    await db
      .updateTable('change_requests')
      .set({
        current_approvals: newApprovalCount,
        approvers: approvers,
        updated_at: toDateValue(new Date())
      })
      .where('id', '=', changeRequestId)
      .execute()

    const readyToDeploy = newApprovalCount >= (cr.required_approvals || 1)

    if (readyToDeploy) {
      await db
        .updateTable('change_requests')
        .set({ status: 'approved' })
        .where('id', '=', changeRequestId)
        .execute()

      try {
        await notificationService.send({
          channel: 'email',
          subject: `Change Request Approved: ${cr.title}`,
          content: `Change request ${cr.title} has been approved and is ready for deployment.`,
          recipients: [{ type: 'user', id: cr.requested_by }]
        })
      } catch (e) { /* ignore */ }
    }

    return { approved: true, readyToDeploy }
  }

  /**
   * Deploy a change
   */
  async deployChange(
    changeRequestId: string,
    deployedBy: string,
    options: { dryRun?: boolean; force?: boolean } = {}
  ): Promise<{ success: boolean; dryRun: boolean; wouldAffect?: ImpactAssessment; restoreResult?: unknown; deployDuration?: number }> {
    const cr = await db
      .selectFrom('change_requests')
      .where('id', '=', changeRequestId)
      .selectAll()
      .executeTakeFirst()

    if (!cr) throw new Error('Change request not found')

    if (cr.status !== 'approved' && !options.force) {
      throw new Error('Change request not yet approved')
    }

    if (options.dryRun) {
      const snapshot = await this.snapshotService.getSnapshot(cr.snapshot_id)
      return {
        success: true,
        dryRun: true,
        wouldAffect: snapshot ? await this.analyzeImpact(snapshot) : undefined
      }
    }

    const deployStart = Date.now()
    try {
      const restoreResult = await this.snapshotService.restoreSnapshot({
        snapshotId: cr.snapshot_id,
        restoredBy: deployedBy,
        restoreType: 'full'
      })

      await db
        .updateTable('change_requests')
        .set({
          status: 'deployed',
          deployed_at: toDateValue(new Date()),
          deployed_by: deployedBy,
          updated_at: toDateValue(new Date())
        })
        .where('id', '=', changeRequestId)
        .execute()

      await auditLog({
        actorId: deployedBy,
        actorType: 'user',
        action: 'deploy_change',
        resourceType: 'change_request',
        resourceId: changeRequestId,
        meta: { restoreResult }
      })

      const deployDuration = (Date.now() - deployStart) / 1000
      // metrics.changeDeploymentDuration.observe(deployDuration)

      try {
        await notificationService.send({
          channel: 'email',
          subject: `Change Deployed: ${cr.title}`,
          content: `Change request ${cr.title} has been successfully deployed to ${cr.target_environment}.`,
          recipients: [{ type: 'user', id: cr.requested_by }]
        })
      } catch (e) { /* ignore */ }

      return {
        success: true,
        dryRun: false,
        restoreResult,
        deployDuration
      }
    } catch (error) {
      try {
        await notificationService.send({
          channel: 'email',
          subject: `Deployment Failed: ${cr.title}`,
          content: `Deployment of change request ${cr.title} failed.\n\nError: ${(error as Error).message}`,
          recipients: [{ type: 'user', id: cr.requested_by }, { type: 'user', id: deployedBy }]
        })
      } catch (e) { /* ignore */ }
      throw error
    }
  }

  /**
   * Rollback a change
   */
  async rollbackChange(
    changeRequestId: string,
    rolledBackBy: string,
    reason: string
  ): Promise<{ success: boolean; rollbackResult: unknown; parentSnapshotId: string }> {
    const cr = await db
      .selectFrom('change_requests')
      .where('id', '=', changeRequestId)
      .selectAll()
      .executeTakeFirst()

    if (!cr) throw new Error('Change request not found')

    if (cr.status !== 'deployed') {
      throw new Error('Can only rollback deployed changes')
    }

    const snapshot = await this.snapshotService.getSnapshot(cr.snapshot_id)
    if (!snapshot || !snapshot.parent_snapshot_id) {
      throw new Error('No parent snapshot available for rollback')
    }

    const rollbackResult = await this.snapshotService.restoreSnapshot({
      snapshotId: snapshot.parent_snapshot_id,
      restoredBy: rolledBackBy,
      restoreType: 'full'
    })

    await db
      .updateTable('change_requests')
      .set({
        status: 'rolled_back',
        rolled_back_at: toDateValue(new Date()),
        rolled_back_by: rolledBackBy,
        rollback_reason: reason,
        updated_at: toDateValue(new Date())
      })
      .where('id', '=', changeRequestId)
      .execute()

    await auditLog({
      actorId: rolledBackBy,
      actorType: 'user',
      action: 'rollback_change',
      resourceType: 'change_request',
      resourceId: changeRequestId,
      meta: { reason, rollbackResult }
    })

    try {
      await notificationService.send({
        channel: 'email',
        subject: `Change Rolled Back: ${cr.title}`,
        content: `Change request ${cr.title} has been rolled back.\n\nReason: ${reason}`,
        recipients: [{ type: 'user', id: cr.requested_by }, { type: 'user', id: 'admin' }]
      })
    } catch (e) { /* ignore */ }

    return {
      success: true,
      rollbackResult,
      parentSnapshotId: snapshot.parent_snapshot_id
    }
  }

  private async assessRisk(snapshot: { id: string; tags?: string[] }, environment: string): Promise<number> {
    let score = 0
    const envWeights: Record<string, number> = { dev: 0.1, staging: 0.3, production: 0.6 }
    score += envWeights[environment] || 0

    // Mock item count check
    const items = await this.snapshotService.getSnapshotItems(snapshot.id)
    if (items.length > 1000) score += 0.2
    
    if (snapshot.tags?.includes('schema-change')) {
      score += 0.3
    }

    return Math.min(1.0, score)
  }

  private async analyzeImpact(snapshot: { id: string; tags?: string[] }): Promise<ImpactAssessment> {
    const items = await this.snapshotService.getSnapshotItems(snapshot.id)
    // Use type guard to filter undefined values and maintain string[] type
    const affectedViews = [...new Set(
      items.map(i => i.view_id).filter((v): v is string => v !== undefined && v !== null)
    )]
    const hasSchemaChanges = snapshot.tags?.includes('schema-change') || false
    const hasDataChanges = items.length > 0

    const riskFactors: string[] = []
    if (items.length > 10000) riskFactors.push('Large dataset')
    if (hasSchemaChanges) riskFactors.push('Schema modification')

    return {
      affectedItems: items.length,
      affectedViews,
      hasSchemaChanges,
      hasDataChanges,
      estimatedDowntime: hasSchemaChanges ? 60 : 0,
      riskFactors
    }
  }

  private async generateChangeNotes(snapshot: { id: string; created_at?: Date; tags?: string[] }): Promise<string> {
    const items = await this.snapshotService.getSnapshotItems(snapshot.id)
    
    const summary = {
      totalItems: items.length,
      itemsByType: {} as Record<string, number>,
    }

    // Count items by type
    for (const item of items) {
      const type = item.item_type || 'unknown'
      summary.itemsByType[type] = (summary.itemsByType[type] || 0) + 1
    }

    // Generate Markdown
    let notes = `## Change Summary\n\n`
    notes += `**Snapshot ID**: ${snapshot.id}\n`
    notes += `**Created At**: ${snapshot.created_at}\n`
    notes += `**Total Items**: ${summary.totalItems}\n\n`

    notes += `### Breakdown by Type\n`
    for (const [type, count] of Object.entries(summary.itemsByType)) {
      notes += `- ${type}: ${count}\n`
    }

    if (snapshot.tags && snapshot.tags.length > 0) {
      notes += `\n### Tags\n`
      notes += snapshot.tags.map((t: string) => `- ${t}`).join('\n')
    }

    return notes
  }

  private generateWarnings(riskScore: number, impact: ImpactAssessment, environment: string): string[] {
    const warnings: string[] = []
    if (riskScore > 0.7) warnings.push('HIGH RISK')
    if (environment === 'production') warnings.push('PRODUCTION DEPLOYMENT')
    return warnings
  }
}

export const changeManagementService = new ChangeManagementService()
