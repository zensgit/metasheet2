name: Attendance Strict Gates (Prod)

# Mark drill runs explicitly so dashboards can ignore them.
run-name: Attendance Strict Gates (Prod)${{ github.event_name == 'workflow_dispatch' && inputs.drill == 'true' && ' [DRILL]' || '' }}

on:
  workflow_dispatch:
    inputs:
      drill:
        description: 'Optional: mark run as [DRILL] and skip calling production APIs (true/false)'
        required: false
        default: 'false'
      drill_fail:
        description: 'Optional: intentionally fail the drill job for FAIL-path validation (true/false)'
        required: false
        default: 'false'
      drill_invalid_summary:
        description: 'Optional: write an intentionally invalid gate-summary.json in drill mode (true/false)'
        required: false
        default: 'false'
      drill_failed_gate:
        description: 'Optional: gate to mark as FAIL in drill gate-summary.json (apiSmoke|provisioning|playwrightProd|playwrightDesktop|playwrightMobile)'
        required: false
        default: 'apiSmoke'
      drill_gate_reason:
        description: 'Optional: reason code for drill_failed_gate when it is not apiSmoke (example: TIMEOUT)'
        required: false
        default: 'TIMEOUT'
      drill_api_smoke_reason:
        description: 'Optional: apiSmoke reason code to embed in drill gate-summary.json (example: AUDIT_EXPORT_SCHEMA_MISSING)'
        required: false
        default: 'AUTH_FAILED'
      issue_title:
        description: 'Optional: override escalation issue title for workflow_dispatch drills (leave empty for production title)'
        required: false
        default: ''
      api_base:
        description: 'API base (must end with /api)'
        required: false
        default: 'http://142.171.239.56:8081/api'
      expect_product_mode:
        description: 'Expected product mode (from /api/auth/me -> features.mode)'
        required: false
        default: 'attendance'
      require_attendance_admin_api:
        description: 'Require attendance admin API endpoints (true/false)'
        required: false
        default: 'true'
      require_idempotency:
        description: 'Require import idempotencyKey retry behavior (true/false)'
        required: false
        default: 'true'
      require_import_export:
        description: 'Require import batch export.csv endpoint (true/false)'
        required: false
        default: 'true'
      require_import_upload:
        description: 'Require CSV upload channel (/attendance/import/upload + csvFileId) (true/false)'
        required: false
        default: 'true'
      require_import_async:
        description: 'Require async import commit gate (true/false)'
        required: false
        default: 'true'
      require_preview_async:
        description: 'Require async import preview gate (true/false)'
        required: false
        default: 'true'
      require_batch_resolve:
        description: 'Require attendance-admin batch user resolve API (true/false)'
        required: false
        default: 'false'
  schedule:
    # Daily at 02:15 UTC.
    - cron: '15 2 * * *'

concurrency:
  group: attendance-strict-gates-prod
  cancel-in-progress: true

permissions:
  contents: read
  issues: write

jobs:
  drill:
    if: github.event_name == 'workflow_dispatch' && inputs.drill == 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 5
    env:
      DRILL_FAIL: ${{ inputs.drill_fail || 'false' }}
      DRILL_INVALID_SUMMARY: ${{ inputs.drill_invalid_summary || 'false' }}
      DRILL_FAILED_GATE: ${{ inputs.drill_failed_gate || 'apiSmoke' }}
      DRILL_GATE_REASON: ${{ inputs.drill_gate_reason || 'TIMEOUT' }}
      DRILL_API_SMOKE_REASON: ${{ inputs.drill_api_smoke_reason || 'AUTH_FAILED' }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Drill no-op (skip strict gates)
        id: run_drill
        run: |
          set -euo pipefail
          DRILL_FAIL="${DRILL_FAIL:-false}"
          DRILL_INVALID_SUMMARY="${DRILL_INVALID_SUMMARY:-false}"
          DRILL_FAILED_GATE="${DRILL_FAILED_GATE:-apiSmoke}"
          DRILL_GATE_REASON="${DRILL_GATE_REASON:-TIMEOUT}"
          DRILL_API_SMOKE_REASON="${DRILL_API_SMOKE_REASON:-AUTH_FAILED}"
          if [[ ! "${DRILL_API_SMOKE_REASON}" =~ ^[A-Z0-9_]+$ ]]; then DRILL_API_SMOKE_REASON="AUTH_FAILED"; fi
          if [[ ! "${DRILL_GATE_REASON}" =~ ^[A-Z0-9_]+$ ]]; then DRILL_GATE_REASON="TIMEOUT"; fi
          case "$DRILL_FAILED_GATE" in
            apiSmoke|provisioning|playwrightProd|playwrightDesktop|playwrightMobile)
              ;;
            *)
              DRILL_FAILED_GATE="apiSmoke"
              ;;
          esac

          reason="$DRILL_GATE_REASON"
          if [[ "$DRILL_FAILED_GATE" == "apiSmoke" ]]; then
            reason="$DRILL_API_SMOKE_REASON"
          fi
          mkdir -p output/playwright/attendance-prod-acceptance/drill
          cat > output/playwright/attendance-prod-acceptance/drill/drill.txt <<'EOF'
          This is a DRILL run for Attendance Strict Gates (Prod).
          The workflow intentionally skips calling production APIs.
          EOF

          # Provide a minimal gate-summary.json so dashboards can exercise
          # artifact parsing without calling production.
          cat > output/playwright/attendance-prod-acceptance/drill/gate-summary.json <<EOF
          {
            "schemaVersion": 1,
            "generatedAt": "1970-01-01T00:00:00Z",
            "apiBase": "<DRILL>",
            "webUrl": "<DRILL>",
            "expectProductMode": "attendance",
            "exitCode": 1,
            "gates": {
              "preflight": "SKIP",
              "apiSmoke": "$([[ "$DRILL_FAILED_GATE" == "apiSmoke" ]] && echo FAIL || echo SKIP)",
              "provisioning": "$([[ "$DRILL_FAILED_GATE" == "provisioning" ]] && echo FAIL || echo SKIP)",
              "playwrightProd": "$([[ "$DRILL_FAILED_GATE" == "playwrightProd" ]] && echo FAIL || echo SKIP)",
              "playwrightDesktop": "$([[ "$DRILL_FAILED_GATE" == "playwrightDesktop" ]] && echo FAIL || echo SKIP)",
              "playwrightMobile": "$([[ "$DRILL_FAILED_GATE" == "playwrightMobile" ]] && echo FAIL || echo SKIP)"
            },
            "gateReasons": {
              "apiSmoke": $([[ "$DRILL_FAILED_GATE" == "apiSmoke" ]] && echo "\"$reason\"" || echo null),
              "provisioning": $([[ "$DRILL_FAILED_GATE" == "provisioning" ]] && echo "\"$reason\"" || echo null),
              "playwrightProd": $([[ "$DRILL_FAILED_GATE" == "playwrightProd" ]] && echo "\"$reason\"" || echo null),
              "playwrightDesktop": $([[ "$DRILL_FAILED_GATE" == "playwrightDesktop" ]] && echo "\"$reason\"" || echo null),
              "playwrightMobile": $([[ "$DRILL_FAILED_GATE" == "playwrightMobile" ]] && echo "\"$reason\"" || echo null)
            }
          }
          EOF

          if [[ "$DRILL_INVALID_SUMMARY" == "true" ]]; then
            invalid_tmp="output/playwright/attendance-prod-acceptance/drill/gate-summary.tmp.json"
            jq '.gates.apiSmoke = "BROKEN"' \
              output/playwright/attendance-prod-acceptance/drill/gate-summary.json > "$invalid_tmp"
            mv "$invalid_tmp" output/playwright/attendance-prod-acceptance/drill/gate-summary.json
            {
              echo ""
              echo "DRILL_INVALID_SUMMARY=true"
              echo "Mutated drill gate-summary.json to invalid contract: gates.apiSmoke=BROKEN"
            } >> output/playwright/attendance-prod-acceptance/drill/drill.txt
          fi

          if [[ "$DRILL_FAIL" == "true" ]]; then
            echo "DRILL_FAIL=true: intentional failure after creating drill artifacts" >&2
            exit 97
          fi

      - name: Validate gate-summary contract (drill)
        if: always()
        run: |
          set -euo pipefail
          ./scripts/ops/attendance-validate-gate-summary.sh output/playwright/attendance-prod-acceptance 1

      - name: Upload drill artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: attendance-strict-gates-prod-${{ github.run_id }}-${{ github.run_attempt }}
          retention-days: 14
          path: |
            output/playwright/attendance-prod-acceptance/**

  strict-gates:
    if: github.event_name != 'workflow_dispatch' || inputs.drill != 'true'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    env:
      API_BASE: ${{ inputs.api_base || vars.ATTENDANCE_API_BASE || 'http://142.171.239.56:8081/api' }}
      AUTH_TOKEN: ${{ secrets.ATTENDANCE_ADMIN_JWT }}
      PROVISION_USER_ID: ${{ vars.ATTENDANCE_PROVISION_USER_ID }}
      EXPECT_PRODUCT_MODE: ${{ inputs.expect_product_mode || 'attendance' }}
      RUN_PREFLIGHT: 'false'
      REQUIRE_ATTENDANCE_ADMIN_API: ${{ inputs.require_attendance_admin_api || 'true' }}
      REQUIRE_IDEMPOTENCY: ${{ inputs.require_idempotency || 'true' }}
      REQUIRE_IMPORT_EXPORT: ${{ inputs.require_import_export || 'true' }}
      REQUIRE_IMPORT_UPLOAD: ${{ inputs.require_import_upload || 'true' }}
      REQUIRE_IMPORT_ASYNC: ${{ inputs.require_import_async || 'true' }}
      REQUIRE_PREVIEW_ASYNC: ${{ inputs.require_preview_async || 'true' }}
      REQUIRE_BATCH_RESOLVE: ${{ inputs.require_batch_resolve || 'false' }}
      HEADLESS: 'true'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'
          cache: 'pnpm'

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Install Playwright browsers
        run: pnpm exec playwright install --with-deps

      - name: Run strict gates twice (remote)
        id: run_strict
        run: |
          set -euo pipefail
          ./scripts/ops/attendance-run-strict-gates-twice.sh

      - name: Validate gate-summary contract (strict)
        if: always()
        env:
          STRICT_OUTCOME: ${{ steps.run_strict.outcome }}
        run: |
          set -euo pipefail
          min_count=1
          if [[ "${STRICT_OUTCOME:-}" == "success" ]]; then
            min_count=2
          fi
          ./scripts/ops/attendance-validate-gate-summary.sh output/playwright/attendance-prod-acceptance "$min_count"

      - name: Validate gate-summary JSON schema (strict)
        if: always()
        env:
          STRICT_OUTCOME: ${{ steps.run_strict.outcome }}
        run: |
          set -euo pipefail
          min_count=1
          if [[ "${STRICT_OUTCOME:-}" == "success" ]]; then
            min_count=2
          fi
          node ./scripts/ops/attendance-validate-gate-summary-schema.mjs \
            output/playwright/attendance-prod-acceptance \
            "$min_count" \
            schemas/attendance/strict-gate-summary.schema.json

      - name: Upload artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: attendance-strict-gates-prod-${{ github.run_id }}-${{ github.run_attempt }}
          retention-days: 14
          path: |
            output/playwright/attendance-prod-acceptance/**

  escalate:
    name: Escalate Issue On Failure (Fast Alert)
    needs: [drill, strict-gates]
    if: always()
    runs-on: ubuntu-latest
    timeout-minutes: 5
    env:
      DRILL: ${{ github.event.inputs.drill || 'false' }}
      ISSUE_TITLE_OVERRIDE: ${{ github.event.inputs.issue_title || '' }}
      DRILL_FAIL: ${{ github.event.inputs.drill_fail || 'false' }}
      DRILL_RESULT: ${{ needs.drill.result }}
      STRICT_RESULT: ${{ needs.strict-gates.result }}
    steps:
      - name: Download strict gate artifacts (for escalation context)
        if: always()
        uses: actions/download-artifact@v4
        with:
          name: attendance-strict-gates-prod-${{ github.run_id }}-${{ github.run_attempt }}
          path: output/escalate/strict

      - name: Build gate summary context
        if: always()
        run: |
          set -euo pipefail

          root="output/escalate/strict"
          out_dir="output/escalate"
          mkdir -p "$out_dir"

          out_md="${out_dir}/gate-summary.md"
          echo "## Gate Summary (artifact snapshot)" > "$out_md"
          echo "" >> "$out_md"

          if [[ ! -d "$root" ]]; then
            echo "- No artifacts downloaded (missing directory: \`$root\`)." >> "$out_md"
            exit 0
          fi

          mapfile -t summaries < <(find "$root" -type f -name 'gate-summary.json' | sort)
          if (( ${#summaries[@]} == 0 )); then
            echo "- \`gate-summary.json\` not found in strict gate artifacts." >> "$out_md"
            exit 0
          fi

          # Keep output short: at most 2 summaries (strict gates runs twice).
          count=0
          for f in "${summaries[@]}"; do
            count=$((count + 1))
            if (( count > 2 )); then
              break
            fi

            echo "- Source: \`$f\`" >> "$out_md"

            # Use jq to avoid heredocs (which can break GitHub YAML parsing).
            exit_code="$(jq -r '.exitCode // "unknown"' "$f" 2>/dev/null || echo unknown)"
            failed="$(jq -r '.gates // {} | to_entries | map(select(.value == "FAIL") | .key) | join(",")' "$f" 2>/dev/null || echo '')"
            reasons="$(jq -r '.gateReasons // {} | to_entries | map(select(.value != null and (.value|tostring) != "") | "\(.key)=\(.value)") | join(" ")' "$f" 2>/dev/null || echo '')"

            echo "  - exitCode=${exit_code}" >> "$out_md"
            echo "  - failed=${failed:-none}" >> "$out_md"
            if [[ -n "$reasons" ]]; then
              echo "  - reasons=${reasons}" >> "$out_md"
            fi
            echo "" >> "$out_md"
          done

      - name: Escalate issue when strict gates failed
        uses: actions/github-script@v7
        with:
          script: |
            const drill = String(process.env.DRILL || '').trim() === 'true'
            const drillFail = String(process.env.DRILL_FAIL || '').trim() === 'true'
            const drillResult = String(process.env.DRILL_RESULT || '').trim()
            const strictResult = String(process.env.STRICT_RESULT || '').trim()
            const titleOverride = String(process.env.ISSUE_TITLE_OVERRIDE || '').trim()
            const gateSummaryPath = 'output/escalate/gate-summary.md'

            const failed = drillResult === 'failure' || strictResult === 'failure'

            // Use a dedicated strict-gates issue title to avoid competing with the
            // Daily Gate Dashboard P0 escalation issue.
            const defaultTitle = '[Attendance Gate] Strict gates fast alert'
            const title = titleOverride || defaultTitle
            const allowIssueOps = !drill || Boolean(titleOverride)
            if (!allowIssueOps) {
              core.info('Drill run: skipping issue operations (no override title).')
              return
            }

            const owner = context.repo.owner
            const repo = context.repo.repo
            const runUrl = `${context.serverUrl}/${owner}/${repo}/actions/runs/${context.runId}`
            const artifactName = `attendance-strict-gates-prod-${context.runId}-${process.env.GITHUB_RUN_ATTEMPT || '1'}`

            let gateSummary = ''
            try {
              if (gateSummaryPath) {
                const fs = require('fs')
                if (fs.existsSync(gateSummaryPath)) {
                  gateSummary = fs.readFileSync(gateSummaryPath, 'utf8')
                }
              }
            } catch {
              gateSummary = ''
            }

            const failureBody = [
              'Automated strict gates escalation.',
              '',
              `Run: ${runUrl}`,
              `jobs: strict=${strictResult || 'unknown'} drill=${drillResult || 'unknown'}${drill && drillFail ? ' (drill_fail=true)' : ''}`,
              '',
              gateSummary ? gateSummary.trim() : '(gate summary missing; download artifacts to inspect `gate-summary.json`)',
              '',
              `Artifacts: ${artifactName}`,
              '',
              'Download:',
              '```bash',
              `gh run download ${context.runId} -n \"${artifactName}\" -D \"output/playwright/ga/${context.runId}\"`,
              '```',
            ].join('\n')

            const q = `repo:${owner}/${repo} type:issue in:title \"${title}\"`
            const search = await github.rest.search.issuesAndPullRequests({
              q,
              sort: 'updated',
              order: 'desc',
              per_page: 20,
            })
            const items = Array.isArray(search.data.items) ? search.data.items : []
            const match = items.find((item) => item && !item.pull_request && item.title === title) || null

            if (!failed) {
              if (!match || match.state !== 'open') {
                core.info('Strict gates recovered; no open fast alert issue to close.')
                return
              }
              const body = [
                'Strict gates recovery detected. Closing fast alert issue.',
                '',
                `Run: ${runUrl}`,
                `jobs: strict=${strictResult || 'unknown'} drill=${drillResult || 'unknown'}`,
                '',
                gateSummary ? gateSummary.trim() : '',
              ].join('\n')
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: match.number,
                body,
              })
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: match.number,
                state: 'closed',
              })
              core.info(`Closed issue #${match.number}`)
              return
            }

            if (match) {
              if (match.state !== 'open') {
                await github.rest.issues.update({
                  owner,
                  repo,
                  issue_number: match.number,
                  state: 'open',
                  body: failureBody,
                })
                core.info(`Reopened issue #${match.number}`)
              } else {
                // Keep the issue body stable, but add a comment with the latest strict gates
                // context for auditability. Avoid duplicate
                // comments for the same runId (rerun attempts share the same run URL).
                const runMarker = `actions/runs/${context.runId}`
                const bodyText = typeof match.body === 'string' ? match.body : ''
                if (bodyText.includes(runMarker)) {
                  core.info(`Issue body already includes run ${context.runId}; skipping duplicate comment.`)
                  return
                }
                try {
                  const comments = await github.rest.issues.listComments({
                    owner,
                    repo,
                    issue_number: match.number,
                    per_page: 100,
                  })
                  const list = Array.isArray(comments.data) ? comments.data : []
                  const exists = list.some((c) => typeof c?.body === 'string' && c.body.includes(runMarker))
                  if (exists) {
                    core.info(`Issue already has a comment for run ${context.runId}; skipping duplicate comment.`)
                    return
                  }
                } catch (error) {
                  core.info(`WARN: failed to list issue comments for dedupe: ${String(error)}`)
                }

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: match.number,
                  body: failureBody,
                })
                core.info(`Commented on existing open issue #${match.number}`)
              }
              return
            }

            const created = await github.rest.issues.create({
              owner,
              repo,
              title,
              body: failureBody,
            })
            core.info(`Created issue #${created.data.number}`)
